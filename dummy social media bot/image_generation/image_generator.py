from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys
import time
import requests
from PIL import Image
from io import BytesIO
import os
import logging
import uuid
import boto3
import re
from selenium.common.exceptions import WebDriverException, StaleElementReferenceException, TimeoutException
from dotenv import load_dotenv

from .utils import content_type_styles, get_content_details

# Load environment variables
load_dotenv()
AWS_REGION = os.getenv("AWS_REGION")
S3_BUCKET_NAME = os.getenv("S3_BUCKET_NAME")
CHROME_PROFILE_PATH = os.getenv("CHROME_PROFILE_PATH")
LOGO_PATH = "logo.png"  # Path to the logo file

# Validate environment variables
if not CHROME_PROFILE_PATH:
    raise ValueError("CHROME_PROFILE_PATH environment variable not set.")
if not AWS_REGION or not S3_BUCKET_NAME:
    raise ValueError("AWS_REGION or S3_BUCKET_NAME environment variable not set.")
if not os.path.exists(LOGO_PATH):
    raise ValueError(f"Logo file not found at {LOGO_PATH}")

# Initialize S3 client
s3 = boto3.client("s3", region_name=AWS_REGION)

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class ImageGenerator:
    def __init__(self):
        self.max_iterations = 5  # Maximum feedback iterations
        self.score_threshold = 9  # Target score for image quality

    def generate_image_prompt(self, subtopic, content_type, style_idx, theme, include_footer=False):
        """
        Generate a dynamic image prompt based on content type and theme.
        """
        title = subtopic["title"]
        details = subtopic["details"]
        caption = subtopic["captions"][0]  # Pick first caption for engagement

        # Remove any numbers (e.g., "1.", "2", etc.) from the caption
        caption = re.sub(r'\b\d+\b\.?', '', caption).strip()

        style = content_type_styles[content_type]
        layout = style["layouts"][style_idx % len(style["layouts"])]

        prompt = f"{style['action']} '{theme}' with a {layout} layout. "
        prompt += f"Use a {style['palette']}, a {style['font']}, and {style['theme_adjustment']}. "
        prompt += f"Include the details: '{details}'. "
        prompt += f"Add the text '{caption}' in yellow at the bottom. "
        prompt += "Ensure the image does not look AI-generated by avoiding overly perfect symmetry, unnatural gradients, or generic digital artifacts; instead, use a hand-crafted aesthetic with slight imperfections, organic textures, and a natural design flow. "

        if include_footer:
            footer_text = "CraftingBrain Â© 2025 | Call: 9115706096 | www.craftingbrain.com"
            prompt += f" Include a footer with '{footer_text}' in white on a black strip with a yellow line above the footer."

        return prompt

    def submit_prompt(self, driver, prompt, max_retries=3):
        """
        Submit a prompt to ChatGPT with retry mechanism to handle stale elements.
        """
        for attempt in range(max_retries):
            try:
                input_field = WebDriverWait(driver, 20).until(
                    EC.element_to_be_clickable((By.XPATH, "//div[@id='prompt-textarea']"))
                )
                logging.info("Input field re-located and clickable.")

                driver.execute_script("arguments[0].innerText = '';", input_field)
                driver.execute_script("arguments[0].click();", input_field)
                driver.execute_script("arguments[0].innerText = arguments[1];", input_field, prompt)
                input_field.send_keys(Keys.ENTER)
                logging.info("Prompt submitted successfully.")
                return True
            except (StaleElementReferenceException, Exception) as e:
                logging.warning(f"Attempt {attempt + 1} failed to submit prompt: {e}")
                time.sleep(2)
                if attempt == max_retries - 1:
                    logging.error(f"Failed to submit prompt after {max_retries} attempts: {e}")
                    return False
        return False

    def download_image(self, img_src, max_retries=3):
        """
        Download an image from a URL with retries for network issues.
        """
        for attempt in range(max_retries):
            try:
                response = requests.get(img_src, timeout=10)
                if response.status_code == 200:
                    return response.content
                else:
                    logging.warning(f"Failed to download image. Status code: {response.status_code}. Attempt {attempt + 1}/{max_retries}")
            except Exception as e:
                logging.warning(f"Error downloading image: {e}. Attempt {attempt + 1}/{max_retries}")
            time.sleep(2)
        logging.error(f"Failed to download image after {max_retries} retries.")
        return None

    def extract_score(self, feedback_text):
        """
        Extract a score out of 10 from the feedback text.
        """
        match = re.search(r'\b(\d{1,2})/10\b', feedback_text)
        if match:
            return int(match.group(1))
        return 0

    def add_logo_to_image(self, image_content):
        """
        Add the logo to the image at the top-right corner.
        """
        try:
            image = Image.open(BytesIO(image_content)).convert("RGBA")
            logo = Image.open(LOGO_PATH).convert("RGBA")

            # Resize logo to 10% of the image width, maintaining aspect ratio
            logo_width = int(image.width * 0.1)
            logo_height = int(logo.height * (logo_width / logo.width))
            logo = logo.resize((logo_width, logo_height), Image.LANCZOS)

            # Calculate position for top-right corner with padding
            padding = 10
            position = (image.width - logo_width - padding, padding)

            # Create a new image to paste logo
            new_image = Image.new("RGBA", image.size)
            new_image.paste(image, (0, 0))
            new_image.paste(logo, position, logo)

            # Convert back to RGB for PNG saving
            buffer = BytesIO()
            new_image.convert("RGB").save(buffer, format="PNG")
            return buffer.getvalue()
        except Exception as e:
            logging.error(f"Error adding logo to image: {e}")
            return image_content

    def generate_images(self, theme, content_type, num_images, subtopics):
        """
        Generate one image per subtopic, save each to S3, and return a list of S3 URLs.
        """
        try:
            # Load content details
            content_details = get_content_details()
            num_subtopics = min(num_images, len(subtopics))

            if num_subtopics < 1 or num_subtopics > 5:
                logging.error("Number of subtopics must be between 1 and 5.")
                return []
            if num_subtopics > len(subtopics):
                logging.warning(f"Only {len(subtopics)} subtopics available. Adjusting to {len(subtopics)}.")
                num_subtopics = len(subtopics)

            # Set up Chrome options
            options = Options()
            options.add_argument(f"user-data-dir={CHROME_PROFILE_PATH}")
            options.add_argument("--disable-blink-features=AutomationControlled")
            options.add_experimental_option("excludeSwitches", ["enable-automation"])
            options.add_experimental_option("useAutomationExtension", False)
            options.add_argument("--start-maximized")

            # Initialize WebDriver
            logging.info("Initializing ChromeDriver...")
            try:
                driver = webdriver.Chrome(options=options)
            except WebDriverException as e:
                logging.error(f"Failed to initialize ChromeDriver: {e}")
                logging.error("Ensure ChromeDriver is installed and matches your Chrome version.")
                return []

            # List to store S3 URLs for all generated images
            image_urls = []

            try:
                logging.info("Opening ChatGPT...")
                driver.get("https://chatgpt.com/")

                logging.info("Waiting for initial input field...")
                WebDriverWait(driver, 20).until(
                    EC.element_to_be_clickable((By.XPATH, "//div[@id='prompt-textarea']"))
                )
                logging.info("Initial input field found and clickable.")

                # Process each subtopic to generate one image per subtopic
                for idx, subtopic in enumerate(subtopics[:num_subtopics], start=1):
                    attempts = 0
                    include_footer = (content_type.lower() == "promotional")
                    current_prompt = self.generate_image_prompt(subtopic, content_type, idx-1, theme, include_footer=False)

                    # Track the best image for this subtopic
                    best_subtopic_image = {
                        "score": 0,
                        "image_content": None,
                        "filename": f"image_{idx}_{uuid.uuid4().hex}.png",
                        "prompt": current_prompt
                    }

                    logging.info(f"Generating image for subtopic {idx}: {subtopic['title']}")
                    logging.info(f"Initial prompt: {current_prompt}")

                    while attempts < self.max_iterations and best_subtopic_image["score"] < self.score_threshold:
                        # Submit the prompt
                        if not self.submit_prompt(driver, current_prompt):
                            logging.error(f"Failed to submit prompt for subtopic {idx} after {attempts + 1} attempts.")
                            break

                        # Wait for image generation
                        time.sleep(120)

                        # Submit a dummy prompt to ensure image is fully rendered
                        dummy_prompt = "Please wait, processing image."
                        self.submit_prompt(driver, dummy_prompt)
                        time.sleep(30)

                        # Locate and download the image
                        img_tags = driver.find_elements(By.TAG_NAME, "img")
                        if not img_tags:
                            logging.error(f"No image found for subtopic {idx} after attempt {attempts + 1}")
                            attempts += 1

                            # Request feedback and revise prompt
                            feedback_prompt = (
                                f"As an expert editor, evaluate the image generation attempt for prompt: '{current_prompt}'. "
                                "The image failed to generate. Assess the prompt's clarity, specificity, and alignment with the theme '{theme}'. "
                                "Provide a score out of 10 for the prompt's effectiveness and suggest a revised prompt to improve visual impact, coherence, and engagement."
                            )
                            self.submit_prompt(driver, feedback_prompt)
                            time.sleep(45)

                            feedback_elements = driver.find_elements(By.XPATH, "//div[contains(@class, 'message')]")
                            feedback_text = " ".join([elem.text for elem in feedback_elements[-2:]])
                            score = self.extract_score(feedback_text)
                            logging.info(f"Feedback for subtopic {idx}, attempt {attempts}: {feedback_text}, Score: {score}")

                            revised_prompt_match = re.search(r"Revised prompt:?:?\s*(.*)$", feedback_text, re.MULTILINE)
                            if revised_prompt_match:
                                current_prompt = revised_prompt_match.group(1).strip("'\"")
                            else:
                                current_prompt += " Enhance with vivid colors, intricate details, and a compelling composition that strongly reflects the theme."
                            logging.info(f"Revised prompt for subtopic {idx}, attempt {attempts + 1}: {current_prompt}")
                            continue

                        img_src = img_tags[-1].get_attribute("src")
                        logging.info(f"Image URL found: {img_src}")

                        # Download the image with retries
                        image_content = self.download_image(img_src)
                        if not image_content:
                            logging.error(f"Failed to download image for subtopic {idx} after attempt {attempts + 1}")
                            attempts += 1
                            continue

                        # Request feedback on the generated image
                        feedback_prompt = (
                            f"As an expert editor for social media content, evaluate the generated image for prompt: '{current_prompt}'. "
                            "Assess creativity (innovative design and visual appeal), clarity (how well it communicates the theme '{theme}'), "
                            "engagement (ability to capture audience attention), and alignment with the intended style ({content_type}). "
                            "Provide a score out of 10 and, if the score is below 9, suggest specific improvements for layout, color scheme, typography, or composition to enhance the image's impact."
                        )
                        self.submit_prompt(driver, feedback_prompt)
                        time.sleep(45)

                        feedback_elements = driver.find_elements(By.XPATH, "//div[contains(@class, 'message')]")
                        feedback_text = " ".join([elem.text for elem in feedback_elements[-2:]])
                        score = self.extract_score(feedback_text)
                        logging.info(f"Feedback for subtopic {idx}, attempt {attempts + 1}: {feedback_text}, Score: {score}")

                        # Update best image for this subtopic if score is higher
                        if score > best_subtopic_image["score"]:
                            best_subtopic_image["score"] = score
                            best_subtopic_image["image_content"] = image_content
                            best_subtopic_image["prompt"] = current_prompt

                        if score >= self.score_threshold:
                            logging.info(f"Image for subtopic {idx} meets quality threshold with score {score}/10")
                            break

                        # Revise prompt based on feedback
                        attempts += 1
                        revised_prompt_match = re.search(r"Revised prompt:?:?\s*(.*)$", feedback_text, re.MULTILINE)
                        if revised_prompt_match:
                            current_prompt = revised_prompt_match.group(1).strip("'\"")
                        else:
                            current_prompt += " Enhance with vivid colors, intricate details, and a compelling composition that strongly reflects the theme."
                        logging.info(f"Revised prompt for subtopic {idx}, attempt {attempts + 1}: {current_prompt}")

                    if attempts >= self.max_iterations:
                        logging.warning(f"Max iterations reached for subtopic {idx}.")

                    # Process the best image for this subtopic
                    if best_subtopic_image["image_content"]:
                        # If promotional, regenerate with footer
                        if content_type.lower() == "promotional":
                            final_prompt = self.generate_image_prompt(
                                subtopic,
                                content_type,
                                idx - 1,
                                theme,
                                include_footer=True
                            )
                            logging.info(f"Generating final image with footer for subtopic {idx} using prompt: {final_prompt}")
                            self.submit_prompt(driver, final_prompt)
                            time.sleep(120)
                            # Submit a dummy prompt to ensure image is fully rendered
                            self.submit_prompt(driver, "Please wait, processing final image.")
                            time.sleep(30)

                            img_tags = driver.find_elements(By.TAG_NAME, "img")
                            if img_tags:
                                img_src = img_tags[-1].get_attribute("src")
                                image_content = self.download_image(img_src)
                                if image_content:
                                    best_subtopic_image["image_content"] = image_content
                                    logging.info(f"Successfully generated final image with footer for subtopic {idx}.")
                                else:
                                    logging.warning(f"Failed to download final image with footer for subtopic {idx}. Using best image from iterations.")

                        # Add logo to the image
                        final_image_content = self.add_logo_to_image(best_subtopic_image["image_content"])

                        # Upload the image to S3
                        buffer = BytesIO(final_image_content)
                        s3.upload_fileobj(buffer, S3_BUCKET_NAME, best_subtopic_image["filename"])
                        image_url = f"https://{S3_BUCKET_NAME}.s3.amazonaws.com/{best_subtopic_image['filename']}"
                        logging.info(f"Image for subtopic {idx} uploaded to S3: {image_url}")
                        image_urls.append(image_url)
                    else:
                        logging.warning(f"No image generated for subtopic {idx}.")

                # Return the list of all S3 URLs
                if image_urls:
                    logging.info(f"All {len(image_urls)} images have been uploaded to S3: {image_urls}")
                    return image_urls
                else:
                    logging.warning("No images were generated successfully.")
                    return []

            except Exception as e:
                logging.error(f"An error occurred during image generation: {e}")
                logging.info("Keeping browser open for inspection for 5 seconds...")
                time.sleep(5)

            finally:
                logging.info("Closing browser automatically in 5 seconds...")
                time.sleep(5)
                driver.quit()
                logging.info("Browser closed.")

            return []

        except Exception as e:
            logging.error(f"Unexpected error in generate_images: {e}")
            return []